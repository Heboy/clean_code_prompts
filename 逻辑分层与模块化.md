# 逻辑分层与模块化

我们之前在架构分层中探讨了如何将代码拆分为 UI 层与逻辑层。本文将继续讨论逻辑层内的分层与模块化，目标是建立一个约定，将不同职责的代码清晰地分离，并按功能将它们组织起来。

- **层（Layers）**：按“职责”对代码进行横向切分。比如，UI 层负责视图渲染，逻辑层负责业务处理，数据层负责与接口通信等。
- **模块（Modules）**：在同一层内，按“功能”对代码进行纵向切分。比如，在逻辑层内，有抢单逻辑、支付逻辑等。

![](https://imagecdn.ymm56.com/ymmfile/static/resource/c550af7d-448c-423b-afe7-9693380d0b8b.png)

## 逻辑分层：流程与规则

逻辑层中的代码可以划分为：**流程（Process）** 与 **规则（Rule）**。

-   **流程**：负责编排和协调一系列操作，以完成一个完整的业务目标。它如同业务场景的“剧本”，定义了“做什么”以及“按什么顺序做”。流程的起点一般是外部事件（如用户点击、消息通知等）。
    
-   **规则**：负责独立的业务计算或验证逻辑。例如，一个计算价格的函数，一个验证表单的函数，或是一个格式化数据的函数。规则通常是**纯函数**，接收输入，返回输出，不应处理副作用（如API请求）。

#### 流程的实现：Hook 与 Thunk

在 React 项目中，流程节点通常是一个**自定义 Hook**。在 Redux-Toolkit 项目中，流程节点可以是**自定义 Hook** 也可以是 **Thunk**。

我们推荐优先使用 Hook。因为 Hook 本身能够访问状态（useState）、执行副作用（useEffect）、访问生命周期（useMount）等，更容易实现关注点分离。

Thunk 则相反，更容易通过`dispatch(next_thunk)`形成串联调用关系。适合于串行的流程比如支付流程等。

#### **流程的分解**

复杂的业务流程可以被分解，顶端流程由多个子流程组成，子流程又由孙子流程组成。这形成了流程内部的横向与纵向层级。纵向层级的深度建议保持在 3 层以内，以防止过度封装。

![](https://imagecdn.ymm56.com/ymmfile/static/resource/d03519bf-0371-4e9c-9ad0-f6559637e575.png)

横向层级内的各节点，要具备相似的抽象粒度。纵向层级中的节点，则应该观察到**抽象级别的清晰变化**。以支付流程为例：

```javascript
export function handlePaymentThunk(button: PaymentConfirmationButton) {
  return async (dispatch: AppDispatch, getState: () => RootState) => {
    // 步骤 1: 调用“规则”进行前置校验
    const preCheckRes = paymentPreCheckResult(getState(), button);
    if (preCheckRes.result === false) {
      dispatch({ type: 'global/setPayHandling', payload: false });
      return;
    }

    // 步骤 2: 调用“规则”构建 API 请求参数
    const grabParams = buildGrabParams(getState(), button);

    // 步骤 3: 执行 API 调用 (副作用)
    const grabData = await grabService(grabParams);

    // 步骤 4: 如果跳过收银台，直接进入“支付成功”流程
    if (grabData.info.skipCashier) {
      dispatch(paySuccessThunk(grabData));
      return;
    }

    // 步骤 5: 调用“规则”处理阻断弹窗逻辑
    const dialogResult = formatOrderGrabDialogResult(grabData);
    if (dialogResult?.dialogData) {
      // ...显示弹窗
    }

    // 步骤 6: 进入“拉起收银台”流程
    const paySuccess = await dispatch(cashierThunk(grabData));

    // 步骤 7: 如果收银台支付成功，则进入“支付成功”流程
    if (paySuccess) {
      dispatch(paySuccessThunk(grabData));
      return;
    }
    // 步骤8: 失败则进入“支付失败”流程
    dispatch(payFailedThunk(grabData))
  };
}
```

要警惕**参数透传**。当一个函数的大部分参数只是为了原封不动地传递给下一个函数时，意味着中间的这层抽象可能是多余的。

#### 层级间的依赖关系

为了维护分层的清晰性，各层之间的调用需要遵循明确的依赖方向，以确保职责的单向流动，避免循环依赖和混乱的架构。

-  **UI 调用流程**：UI 组件通过调用 **流程 (Process)** 来触发业务逻辑。这是业务逻辑的入口，确保了 UI 层的职责纯粹：响应用户交互，并将业务意图传递给流程层。
   
-  **流程调用规则**：**流程 (Process)** 在编排业务、处理副作用时，可以调用一个或多个 **规则 (Rule)** 提供的原子能力来完成复杂的业务任务。
   
-  **规则不能调用流程**：**规则 (Rule)** 作为纯粹的、低阶的构建块，对上层业务一无所知，因此不应反向依赖或调用任何 **流程 (Process)**。
   
-  **流程间的调用**：一个 **流程 (Process)** 调用另一个 **流程 (Process)** 是允许的。比如在组件间流转控制权，以及父子流程间的调用。
   
-  **规则间的调用**：一个 **规则 (Rule)** 调用另一个 **规则 (Rule)** 同样是允许的。它鼓励在底层实现逻辑的复用与组合，例如，一个复杂的计算规则可以由多个更简单的规则组合而成。

## 如何设计模块？

在分层的基础上，我们来讨论如何将代码组织成“模块”。模块即可以是一个“子流程”，也可以是一个“规则”。好的模块应该像一个设计精良的工具：单一职责，接口简单，功能强大。

#### 如何判断哪些代码应该放在同一个模块里？

- **概念重叠**：如果多个逻辑在概念上高度相关，它们应该归入同一个模块
- **总是同时使用**：如果多个逻辑总是被一起调用或使用，它们应该归入同一个模块
- **分开难以理解**：如果将某些逻辑分开会导致代码难以理解或维护，它们应该归入同一个模块
- **共享信息**：如果多个逻辑共享相同的数据或状态，它们可能属于同一个模块

#### 通过**代码行数**来判断模块粒度是否合理。

- 函数：合理的行数在 100 行以内，不要超过 200 行
- 文件/类：合理的行数在 250 行以内，不要超过 400 行

#### 为模块设置合理的可见性。

对于单个文件，使用“导出（export）“实现可见性控制。公开方法（public）放在模块顶部，私有方法（private）放在公开方法之后。

```javascript
// public
export function calculateMutexInsuranceList() {...}
export function getMutexNames() {...}
// private
function getExcludeList() {...}
```

对于包含多个文件的模块，使用“重导出（re-exporting）”控制可见性。以 payment 模块为例，包含多个子流程/规则，目录结构如下：

```bash
payment/                           # 支付模块
├── handle-payment-thunk.ts        # 公开方法，执行支付流程
├── index.ts                       # 模块入口，重导出所有公共方法
├── monthly-pay-result-thunk.ts    # 私有方法，月付结果
├── monthly-payment-thunk.ts       # 私有方法，使用月付
├── open-cashier-thunk.ts          # 私有方法，拉起收银台
├── order-grab-params.ts           # 私有方法，组装grab参数
└── ...
```

index.ts是模块入口，将公开方法在这里重导出：

```javascript
export * from "./handle-payment-thunk";
```

其他模块引用payment时：

```javascript
import { handlePaymentThunk } from "src/path/payment"; // ✅
import { handlePaymentThunk } from "src/path/payment/handle-payment-thunk"; // ❌ 通过“重导出”引用公开方法
import { openCashierThunk } from "src/path/payment/open-cashier-thunk"; // ❌ 不得引用私有方法
```

## 总结

本文档为 React 应用提供了一套架构约定，其核心目标是通过**分层**与**模块化**来提升代码的可读性、可维护性和可扩展性。

我们首先将逻辑层拆分为两个核心概念：

1.  **流程 (Process)**：负责编排业务，如同剧本。我们推荐优先使用自定义 Hook 来实现，仅在处理复杂的长串行工作流时才考虑使用 Thunk。
2.  **规则 (Rule)**：负责纯粹的计算与验证，必须是无副作用的纯函数。

在此基础上，我们建立了严格的**单向依赖原则**：流程可以调用规则，但规则绝不能反向依赖流程。

最后，我们强调了**模块化封装**的重要性。通过明确的组织原则（如概念相关、功能内聚）和可见性控制，确保了模块的高内聚、低耦合。

遵循这些原则，我们可以构建出一个职责清晰、易于协作和长期维护的健壮应用。
